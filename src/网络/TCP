![](images/TCP格式.png)
TCP头格式解析：
1. 16位端口号，源端口号和目标端口号
2. 32位消息序列号，TCP为每个消息的字节进行编号，开始序号值被初始化为某个随机值ISN（initial sequence number） 
若TCP报文是字节流第1025~2048字节，则序号值是ISN+1025
3. 32位确认号（acknowledgement number）用作接收端对一段报文的确认，其值是收到TCP报文段序号值加1 
4. 4位头部长度（header length）标识TCP头部有多少个32bit字，最大为15，所以TCP头部最长60字节。 
5. 6位标志位，URG标志，表示紧急指针（urgent poinnter）是否有效 
         ACK标志，表示确认号是否有效 
         PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，腾冲空间 
         RST标志，表示要求对方重新建立连接。 带此标志的报文段称为复位报文段 
         SYN标志，表示请求建立一个连接。带此标志的报文段称为同步报文段 
         FIN标志，表示通知对方本端要关闭连接了。带此标志的报文段称为结束报文段
6. 16位窗口大小（window size） 流量控制 告诉对方还能容纳多少个字节数据
7. 16位校验和（TCP checksum）CRC校验头部和数据部分
8. 16位紧急指针（urgent pointer） 正偏移量。他和序号字段的值相加表示最后一个紧急数据的下一字节的序号.发送紧急数据的方法。

- TCP建立连接的三次握手
![TCP三次握手](./images/TCP三次握手.png)
最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。
1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 
- 为什么TCP客户端最后还要发送一次确认呢？
一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。
此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

如果你用过对讲机你就会明白：
C ->S: 你能听到吗？
S->C: 听到。你能听到我吗？
C->S:听到。

- TCP关闭连接的四次挥手
![TCP四次挥手](./images/TCP四次挥手.png)

![TCP四次挥手](./images/TCP四次挥手1.png)
数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

- 为什么客户端最后还要等待2MSL？
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

为什么建立连接是三次握手，关闭连接确是四次挥手呢？
总结：（1）为了使服务端最后可以收到客户端对服务端发送的FIN+ACK信号的确认ACK，当客户端发送的ACK信号发生了延迟或走丢，那么服务端可以在超时
的时候重新发送一次FIN+ACK，而这次延迟最长的时间是MSL。服务端再发送一次FIN+ACK同样可能发生延迟或丢包，这个过程的延迟同样是MSL。则2MSL可以确保使得最后服务端可以正常的关闭连接。
（2）避免了客户端与服务端用同样的端口号再次连接之后，旧的连接中的请求对新连接造成干扰，2MSL可以确保此连接的所有请求都已经失效

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
- 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
- TCP可靠性保障机制
1. 确认应答
TCP的确认应答机制就是，发送端给接收端发送的数据，当接收端收到之后会返回一个确认消息，这个确认消息也就是确认应答ACK

TCP的确认应答机制是基于序列号实现的，这个序列号也就是我们TCP报头中的序号和确认序号。TCP的报文到达确认，是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号。例如，主机A发送的当前数据序号是1，数据长度是400，则接收端收到后会返回一个确认号是401的确认号给主机A，表示下次想从401开始接收数据。 
![](./images/TCP确认应答.png)
可以看出来，TCP通过这种确认应答机制来判断接收端是否收到发送端发出的数据。 
可是如果发生数据包丢失，或者确认应答丢失的情况怎么办呢？ 
超时重传机制就可以解决这个问题
2. 超时重传
超时重传机制指定是，发送的数据包在没有收到相应的ACK，等待一段时间，超时之后就会认为这个数据包丢失了，就会重新发送。 
![](./images/TCP超时重传.png)
如图所示主机B由于网络或其他原因没有收到主机A发送的数据(也可能是主机B收到数据后检测到该数据包有差错而丢弃)，主机A只要超过了一段时间仍然没有收到主机B的确认应答就会认为刚才发送的报文丢失了，因而重传该报文。

再想想，如果是主机B的确认报文丢失了呢？ 
![](./images/TCP超时重传1.png)
同样的，主机A没有收到主机B的确认就会重发刚刚发送的数据，那么主机B不就会有重复数据了吗？我们利用刚刚谈过确认应答机制中序号就很容易做到去除重复包

TCP在实现超时重传时要注意以下几点：

主机A在发送完一个报文后，必须暂时保留已发送分组的副本，只有在收到相应的确认之后才能清除
报文和确认报文都要进行编号，这样才能明确哪一个是发送出去的，哪一个还没有收到确认
超时重传的时间应当比数据在传输的平均往返时间要长
这个超时重传时间的选择是一个比较复杂的问题，如果设置的过短，就会引起很多报文段不必要的重传使网络负载增大；如果设置的过长又会使网络空闲的时间增大，降低了传输效率。 
TCP采用了一种自适应算法，它记录了一个报文段发出的时间，以及收到相应的确认时间，这两个时间之差就是报文段的往返时间RTT，根据这个RTT在动态计算这个最大超时时间。Linux中超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍
3. 滑动窗口
刚刚说到的确认应答机制，对每一个发送的数据段都要给一个确认报文，收到ACK之后再发送下一个数据段，可以发现这样的效率比较低 
来优化一下效率低的缺点，比如我让发送的每一个包都有一个序号，接收端必须对每一个包进行确认，这样主机A一次多发送几个片段，而不必等候ACK，同时接收端也要告知它能够收多少，这样发送端发起来也有个限制，当然还需要保证顺序性，不要乱序，对于乱序的状况，我们可以允许等待一定情况下的乱序，比如说先缓存提前到的数据，然后去等待需要的数据，如果一定时间没来就丢弃掉，来保证顺序性

滑动窗口就可以解决这个问题，来看看滑动窗口的数据是怎么分类的： 
![](images/TCP发送滑动窗口.png)
1. 已发送成功且受到确认的数据：例如图中的前29个Bytes，这些数据的位置其实已经在窗口之外了，因为当窗口内最小的序号被确认之后窗口就要向前移动 
2. 已经发送但还没有收到确认的数据： 数据已经被发送出去了，但是还没有收到接收端的确认，发送端就认为并没有完成发送这些数据就还保留在窗口内。(也是为了可能需要重传做准备) 
3. 允许发送但还没有发送的数据：这部分数据已经被加载到缓存中也就是窗口中了，这就说明这些数据还是可以被接收方接受的，所以发送方需要尽快的发送这些数据 
4. 没有发送也不允许的数据：这些数据是发送端没有发送同时接收端也没有能力接收的数据。

上面我们说的窗口其实是发送端的发送窗口，同样的接收端也会有自己的接受窗口。类似于发送端，接收端的数据有3个分类。因为接收端并不需要等待ACK，所以它没有接收并确认了的分类 
![](./images/TCP接收滑动窗口.png)
1. 已经发送确认并交付主机数据：如图中，在接受窗口外面，到29号为止的数据都是已经发送过确认并交付给主机了，因此在接受窗口中就不用再保留这些数据了。 
2. 允许接受的数据：接受窗口中的内的序号(30~40)是允许接收的。在图中主机B收到了31和32的数据，这些数据没有按序到达，因为30号数据没有收到(可能丢失也可能滞留在网络中)，所以主机B发送的确认报文只能是31。 
3. 不允许接受的数据：这些数据是接收端不允许接收的，只能等待窗口中有数据确认窗口前移才会被允许接受。

滑动窗口的原理
继续上图来解释原理：
![](./images/TCP滑动窗口.png)
如上图所示，假设发送窗口的大小为20字节，其中30号字节之前数据都是已经发送而且受到了接收端确认的数据了。再来看看窗口中的数据，窗口中的数据可以被分为两部分，一部分表示已经发送出去但是还没有收到确认的数据，另一部分表示还没有发送但是允许发送的数据。最后一部分就是在窗口之外，表示不允许发送的数据。 
与发送窗口对应的就是接受窗口了，同样的30号字节之前的数据都是已经发送确认并交付给上层应用的数据，而接受窗口中就保存着可以接受的数据，接受窗口外面就是不允许接受的数据。

来看看传送数据之后的变化： 
![](./images/TCP滑动窗口1.png)
发送端收到了接收端对30~34号字节发送的确认，这时发送窗口就会向前移动，产生一些新的空位，这些空位容纳的就是允许发送的数据

来总结一下滑动窗口工作的原理：

假设30~44 这些数据，是上层应用发送给TCP的，TCP将其分成四个数据段来发送
seg1：30~32；seg2：33~34；seg3：35~40；seg4：41~44；这四个片段，依次发送出去，此时假设接收端之接收到了seg1、seg2和seg4
此时接收端的就回复一个ACK包说明已经接收到了30~34的数据，并将seg4进行缓存，因为seg4没有按序到达
发送端收到ACK之后，就会将30~34的数据包从发送但没有确认移动到发送并已经确认，这个时候窗口向右移动
假设接收端的窗口大小没有发生变化，此时窗口右移，产生一些新的空位，这些是接收端允许发送的范畴
对于丢失的seg3，如果超过一定时间，TCP就会进行超时重传，重传成功seg3和seg4就一块被确认，不成功，seg4也将被丢弃
滑动窗口得到原理就是不断重复上述过程，随着窗口不断滑动，将整个数据流发送到接收端，实际上接收端的窗口大小也是会变化的，接收端会根据这个值来确定何时应该发送多少数据
4. 流量控制
先来说说什么是流量控制：流量控制就是让发送端发送数据的速度不要过快，要让接受端来的及接收，因为接收端处理数据的速度是有限的，如果发送端发送的过快，导致接收端的缓冲区被打满，这个时候发送端要是继续发送数据就会出现数据报丢包的问题，继而引起重传等一系列机制。所以TCP有了流量控制，来决定发送端发送数据的速度 
TCP是利用大小可变的滑动窗口来实现的，在最开始建立连接的时候，发送端和接收端会通过TCP首部窗口大小字段来协商发送窗口的大小，但在通信过程中，接收端也可以根据自己的情况来动态调整对方发送窗口的最大值。 
来看个例子吧： 
假设最开始，B告诉A自己的接受窗口rwnd=400，所以发送方的发送窗口不能超过接收方给出的接收窗口的数值。再设每一个报文段的大小是100字节的，而报文段初始序号为1。 
![](./images/TCP流量控制.png)
从图中可以看到，主机B一共进行了3次流量控制。第一次将接收窗口rwnd减小到300，第二次减小到100，最后一次减小到0。也就是不允许主机A发送数据了。这种状态将持续到主机B重新发过来一个新的窗口值为止。 
再来假设一种场景，主机B接收缓存中的数据已经被取走，所以主机B向主机A发送了rwnd=400的报文段，可是这个报文段再发送过程中丢失了。A一直等待B发送窗口大小，而B也一直等待A发送数据，如果没人来打破这个僵局，那就一直是互相等待的死锁局面了。 
为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知就启动这个计时器。如果计时器设置的时间到了还没有收到对方的接收窗口，就给对方发送一个零窗口探测报文段，这个报文段仅携带一字节的数据，而对方收到这个探测报文段就会给出自己现在的窗口值。
5. 拥塞控制
在网络实际的传输过程中，会出现这样的现象。当前的网络上充斥的大量的数据包，却不能被按时送达，已经产生了拥塞的情况，这时候如果还发送大量的数据无疑是雪上加霜。所以TCP就有了拥塞控制，通过拥塞控制来缓解网络的压力。 
拥塞控制主要有四个算法：

慢启动
拥塞避免
拥塞控制时，快重传
快恢复
先来看看慢启动和拥塞避免： 
![](./images/TCP拥塞控制.png)
慢启动算法的思想：在刚刚开始发送报文段的时候，先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。 
在图中。一开始将拥塞窗口cwnd的初始值设为1，表明可以传一个MSS的数据。以后发送方每收到一个对新报文段的确认ACK，就将拥塞窗口值加1，然后开始下一轮的传输。当过了一个往返时间RTT cwnd=cwnd*2，因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢启动的门限值ssthresh时，就改为执行拥塞避免算法。 
拥塞避免算法的思想：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样，拥塞窗口cwnd按线性规律规律缓慢增长。 
就像图中到达门限值之后，cwnd每经过一个RTT就加一，按照线性规律增长。 
假设到cwnd达24的时候网络出现拥塞，更新后的ssthresh值为12，拥塞窗口再重新设置为1，并执行慢启动算法。当cwnd=ssthresh=12时，该执行拥塞避免算法。

还有两个拥塞控制算法就是快重传和快恢复。 
快重传：首先，快重传算法要求接收方每收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发数据时才进行捎带确认。并且快重传算法规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期。 
与快重传配合的就是快恢复算法了。 
快恢复算法的过程中有两个要点：

当发送方收到三个重复确认时，就执行”乘法减小”算法，把慢启动门限值ssthresh减半。
由于发送方会认为现在网络没有拥堵，因此现在不执行慢启动算法，而是把cwnd值设置为慢启动门限ssthresh减半之后的数值，然后开始执行拥塞避免算法。

总结：为了保证TCP的可靠传输，TCP分别提出了8中机制： 
1.确认应答机制 
2.超时重传机制 
3.滑动窗口机制 
4.快速重传机制 
5.流量控制机制 
6.拥塞控制机制 
7.延时应答机制 
8.捎带应答机制