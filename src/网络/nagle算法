参考文档<https://blog.csdn.net/sinat_35261315/article/details/79392116>
Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。
Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议（停止等待ARQ协议），只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低。
nagle算法的核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送

nagle算法可以减少网络中微小分组的数量，比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组

在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动nagle），总共发送的报文段（分组）个数为5

当开启nagle算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2

可以看到，当传输数据存在大量交互数据时，nagle算法可以有效减少网络中的报文段个数

下面通过wireshark抓包分析nagle算法，客户端服务器的执行流程为

建立连接
客户端将字符串”hello”发送给服务器，但是每次只发送一个字节（即连续调用5次send/write函数）
服务器收到客户端的数据后将其缓存，等到全部收到后将其发回客户端
通过wireshark观察网络中报文段的传输
![](./images/TCP开启nagle算法.png)
对图中结果进行分析

1-3行是三次握手
4-5行是发送字节’h’以及服务器的应答
6-7行是发送字节’e’以及服务器的应答
8-9行是发送字节’llo’以及服务器的应答
10行是服务器发送的”hello”报文段
11-14行是四次挥手
可以看到nagle算法确实将待发送的小分组重新分组，等到上一个小分组确认报文到达后一起发送
- 禁止nagle算法
虽然nagle算法可以减少网络中小分组的个数，但是对于那些需要实时预览的通讯程序而言，客户端可能需要不断发送更新数据并得到服务器的响应，这种情况下nagle算法会造成客户端明显的延迟，所以需要禁用nagle算法

将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法
还是以上面的程序为例，这回将nagle算法禁止，观察wireshark抓包结果，预计客户端TCP可以连续发送小报文段而不需要等待上一个小报文段的确认
