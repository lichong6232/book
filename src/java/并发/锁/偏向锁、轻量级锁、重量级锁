1.偏向锁
![偏向锁、轻量级锁、重量级锁转化图](../image/偏向锁-轻量级锁-重量级锁.png)

![偏向锁、轻量级锁、重量级锁转化图](../image/偏向锁-轻量级锁-重量级锁转化图1.png)
偏向锁的获取方式：在对象头的markWord中标记线程的threadId,以表示哪个线程获得了偏向锁。
具体步骤：
（1）读取锁对象的markWord，判断是否处于可偏向状态<br/>
（2）如果为可偏向状态，则尝试用CAS操作将自己的线程Id写入markWord，如果CAS操作成功
则认为已经获取到该对象的偏向锁、则开始执行同步代码块。如果CAS操作失败，则说明有另一个线程
抢先获取了偏向锁，此时需要撤销偏向锁。将持有偏向锁的线程到达安全点，暂停持有偏向锁的线程，检测偏向锁
线程的状态，如果此时偏向锁线程已经退出同步代码块则将锁状态标记为无锁。然后CAS操作失败的线程重新进行步骤（1）（2）。
如果原偏向锁线程未退出同步代码块，则进行锁升级。<br/>
（3）如果已经是偏向锁状态，则坚持markWord中的threadId是否为当前线程、如果是，则证明本线程
已经获得了偏向锁，可以直接继续执行同步代码块。如果不是，则进行偏向锁的撤销操作。<br/>
偏向锁的撤销操作：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，
线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），
它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，
撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
ps:偏向锁这个机制很特殊， 别的锁在执行完同步代码块后， 都会有释放锁的操作， 而偏向锁并没有直观意义上的“释放锁”操作。
那么作为开发人员， 很自然会产生的一个问题就是， 如果一个对象先偏向于某个线程， 执行完同步代码后， 
另一个线程就不能直接重新获得偏向锁吗？ 答案是可以， JVM 提供了批量再偏向机制（Bulk Rebias）机制<br/>

该机制的主要工作原理如下：

- 引入一个概念 epoch, 其本质是一个时间戳 ， 代表了偏向锁的有效性
- 从前文描述的对象头结构中可以看到， epoch 存储在可偏向对象的 MarkWord 中。
- 除了对象中的 epoch, 对象所属的类 class 信息中， 也会保存一个 epoch 值
- 每当遇到一个全局安全点时， 如果要对 class C 进行批量再偏向， 则首先对 class C 中保存的 epoch 进行增加操作， 得到一个新的 epoch_new
- 然后扫描所有持有 class C 实例的线程栈， 根据线程栈的信息判断出该线程是否锁定了该对象， 仅将 epoch_new 的值赋给被锁定的对象中。
- 退出安全点后， 当有线程需要尝试获取偏向锁时， 直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等， 则说明该对象的偏向锁已经失效了， 可以直接通过 CAS 操作尝试再次将该对象再次偏向于请求获得锁的线程。
2.轻量级锁<br/>
2.1加锁过程<br/>
（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如下图所示。<br/>
![轻量级锁CAS操作之前堆栈与对象的状态](../image/轻量级锁CAS操作之前堆栈与对象的状态.png)
（2）拷贝对象头中的Mark Word复制到锁记录中。<br/>

（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word中"指向栈中锁记录的指针"更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。<br/>

（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。<br/>
![轻量级锁CAS操作之后堆栈与对象的状态](../image/轻量级锁CAS操作之后堆栈与对象的状态.png)

（5）如果这个更新操作失败了（更新失败是因为通过CAS操作，CAS操作的期望的mark word为原始mark word，如果有其他线程获取到轻量级锁，则markWord中的内容已经做了修改，所以会更新不成功），虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。
否则说明多个线程竞争锁，此线程会先进行CAS自旋，如果自旋一定次数仍然没有成功，则轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。<br/>
2.2解锁过程<br/>
（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。<br/>
（2）如果替换成功，整个同步过程就完成了。<br/>
（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。<br/>
