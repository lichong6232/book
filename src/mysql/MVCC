参考文档：<https://blog.csdn.net/w2064004678/article/details/83012387><br/>
- 基本原理

MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，
在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。
- InnoDB存储引擎MVCC的实现策略

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

- MVCC下InnoDB的增删查改是怎么work的

1、插入数据（insert）:记录的版本号即当前事务的版本号
  
执行一条数据语句：insert into testmvcc values(1,"test");

假设事务id为1，那么插入后的数据行如下：
![](./image/1536286392011332dc79980.jpeg)
2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。
  
  比如，针对上面那行记录，事务Id为2 要把name字段更新
  
  update table set name= 'new_value' where id=1;
![](./image/15362864790262a85896e55.jpeg)
3、删除操作的时候，就把事务版本号作为删除版本号。比如
  
  delete from table where id=1;
![](./image/15362865324150dfbc7bf66.jpeg)
4、查询操作<br/>
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：

1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)

2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。

（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）<br/>
补充：

1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.

2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.

原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。

3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

ps:还有一点需要说明的是，在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

 

那哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：

 

快照读：简单的select操作，属于快照读，不加锁：

 
select * from table where A=?;

 

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

 
select * from table where A=? lock in share mode;

select * from table where A=? for update;

insert into table values (…);

update table set A=? where B=?;

delete from table where A=?;

 

所有以上的语句，都属于当前读，读取记录的最新版本。并且读取之后，还需要保证其它并发事务不能修改当前记录，对读取记录加锁。其中除了第一条语句，对读取记录加S锁 (共享锁)外，其它的操作，都加的是X锁 (排它锁)。
